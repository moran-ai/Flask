# 数据库

### 外键策略

```mysql
-- 策略三  置空操作
-- 先删除之前的外键
alter table t_student drop FOREIGN KEY fk_stu_classno;

-- 重新添加外键约束
alter table t_student add CONSTRAINT fk_stu_classno FOREIGN key (classno) REFERENCES t_class(c_no) on update set null on delete set null;

-- 尝试更新
update t_class set c_no = 8 where c_no = 5;

-- 进行删除
delete from  t_class where c_no = 2;

-- 
update t_student set classno = 1 where son = 1;

SELECT * from t_student;
select * from t_class;

-- 策略一  no action 什么都不允许做
-- 先把学生对应的班级改为null 
update t_student set classno=null where classno 2;

-- 删除班级2
delete from t_class  where c_no = 2;

-- 策略2 cascade 级联操作 操作主表时，同时修改从表的信息
-- 先删除之前的外键约束
alter table t_student drop FOREIGN KEY fk_stu_classno;

-- 重新添加外键约束
alter table t_student add  CONSTRAINT fk_stu_classno FOREIGN KEY(classon) REFERENCES t_class(c_no) on update CASCADE on delete cascade;

-- 试试更新
update t_class set c_on where c_on = 3;
```

### DDL和DML的补充

```MySQL
-- 创建一个student表
create table student (
	sno int(6) PRIMARY key auto_increment,
	sname varchar(10) not null,
	sex char(1) default '男' check(sex='男' || sex='女'),
	age int(1) check(age>= 18 and age<= 50),
	enterdate date,
	classname varchar(10),
	email varchar(15) UNIQUE
);

select * from student;
desc student;

-- 添加数据
insert into student values (null, '张三', '男', 19, '2021-9-8', 'python1班', 'zs@163.com');
insert into student values (null, '王梅', '女', 20, '2022-8-6', 'python2班', 'wm@163.com');
insert into student values (null,'王五', '男', 30, '2023-9-5', 'python3班', 'ww@163.com');

-- 快速添加一张表 结构和student一致
create table student1 as select * from student;
select * from student1;

-- 快速添加一张表 结构和student一致，但是不需要数据
create table student2  as select * from student where FALSE;
select * from student2;


-- 快速添加一张表，只要部分结构，部分数据
create table student3 as select sno,sname,sex from student where sno=2;
select * from student3;

-- 删除操作 只是清空数据
delete from student;
truncate table student;

/*
delete和truncate的区别：
	delete为数据操作语言 DML truncate为数据定义语言DDL
	delete操作是将数据表中的数据一条条进行删除，直到删除完毕；truncate相当于是保留表的
结构，重新创建了这个表，所有的状态相当于是新表，因此，truncate的执行效率更高
delete可以回滚   truncate不可以回滚
delete会返回删除候的个数 truncate不会
*/
```

### DQL表的准备

```mysql
/*
准备四张表  dept(部门表)  emp(员工表)  salgrade(薪资等级表) bonus(奖金表)
*/
create table DEPT(
	DEPTNO int(2) not null,
	DNAME VARCHAR(14),
	LOC VARCHAR(13)
);

-- 添加主键
ALTER TABLE DEPT add CONSTRAINT PK_DEPT PRIMARY KEY(DEPTNO);

create table EMP
(
	EMPNO INT(4) PRIMARY KEY,
	ENAME VARCHAR(10),
	JOB VARCHAR(10),
	MGR INT(4),
	HIREDATE DATE,
	SAL DOUBLE(7,2),
	COMM DOUBLE(7,2),
	DEPTNO INT(2)
);

-- 添加外键
alter table EMP ADD CONSTRAINT FK_DEPTNO FOREIGN KEY(DEPTNO) REFERENCES DEPT(DEPTNO);

CREATE TABLE SALGRADE
(
	GRADE INT PRIMARY KEY,
	LOSAL DOUBLE(7,2),
	HTSAL DOUBLE(7,2)
);

CREATE TABLE BONUS
(
	ENAME VARCHAR(10),
	JOB VARCHAR(9),
	SAL DOUBLE(7,2),
	COMM DOUBLE(7,2)
);

INSERT INTO DEPT (DEPTNO,DNAME,LOC) VALUES (10, 'ACCOUNTING','NEW YORK');
INSERT INTO DEPT (DEPTNO,DNAME,LOC) VALUES (20, 'RESEARCH','DALLAS');
INSERT INTO DEPT (DEPTNO,DNAME,LOC) VALUES (30, 'SALES','CHICAGO');
INSERT INTO DEPT (DEPTNO,DNAME,LOC) VALUES (40, 'OPERATIONS','BOSTOM');

INSERT INTO EMP(EMPNO,ENAME,JOB,MGR,HIREDATE,SAL,COMM,DEPTNO) VALUES (7369,'SMITH','CLERK',7902,'1980-12-17',800,NULL,20);
INSERT INTO EMP(EMPNO,ENAME,JOB,MGR,HIREDATE,SAL,COMM,DEPTNO) VALUES (7499,'ALLEN','SALESMAN',7698,'1981-02-20', 1600, 300,30);
INSERT INTO EMP(EMPNO,ENAME,JOB,MGR,HIREDATE,SAL,COMM,DEPTNO) VALUES (7521,'WARD','SALESMAN',7698,'1981-02-22', 1250, 500,30);
INSERT INTO EMP(EMPNO,ENAME,JOB,MGR,HIREDATE,SAL,COMM,DEPTNO) VALUES (7566,'JONES','MANAGER',7839,'1981-04-02', 2975, NULL,20);
INSERT INTO EMP(EMPNO,ENAME,JOB,MGR,HIREDATE,SAL,COMM,DEPTNO) VALUES (7654,'MARTIN','SALESMAN',7698,'1981-09-28', 1250, 1400,30);
INSERT INTO EMP(EMPNO,ENAME,JOB,MGR,HIREDATE,SAL,COMM,DEPTNO) VALUES (7698,'BLAKE','MANAGER',7839,'1981-05-01', 2850, NULL,30);
INSERT INTO EMP(EMPNO,ENAME,JOB,MGR,HIREDATE,SAL,COMM,DEPTNO) VALUES (7782,'CLARK','MANAGER',7839,'1981-06-09', 2450, NULL,10);
INSERT INTO EMP(EMPNO,ENAME,JOB,MGR,HIREDATE,SAL,COMM,DEPTNO) VALUES (7788,'SCOTT','ANALYST',7566,'1981-04-19', 3000, NULL,20);
INSERT INTO EMP(EMPNO,ENAME,JOB,MGR,HIREDATE,SAL,COMM,DEPTNO) VALUES (7839,'KING','PRESIENT',NULL,'1981-11-17', 5000, NULL,10);
INSERT INTO EMP(EMPNO,ENAME,JOB,MGR,HIREDATE,SAL,COMM,DEPTNO) VALUES (7844,'TURNER','SALESMAN',7698,'1981-09-08', 1500, 0,30);
INSERT INTO EMP(EMPNO,ENAME,JOB,MGR,HIREDATE,SAL,COMM,DEPTNO) VALUES (7876,'ADAMS','CLERK',7788,'1987-05-23', 1100, NULL,20);
INSERT INTO EMP(EMPNO,ENAME,JOB,MGR,HIREDATE,SAL,COMM,DEPTNO) VALUES (7900,'JAMES','CLERK',7698,'1981-12-03', 950, NULL,30);
INSERT INTO EMP(EMPNO,ENAME,JOB,MGR,HIREDATE,SAL,COMM,DEPTNO) VALUES (7902,'FORD','ANALYST',7566,'1981-12-03', 3000, NULL,20);
INSERT INTO EMP(EMPNO,ENAME,JOB,MGR,HIREDATE,SAL,COMM,DEPTNO) VALUES (7934,'MILLER','CLERK',7782,'1982-01-23', 1300, NULL,10);

INSERT INTO SALGRADE(GRADE, LOSAL, HTSAL) VALUES(1, 700, 1200);
INSERT INTO SALGRADE(GRADE, LOSAL, HTSAL) VALUES(2, 1201, 1400);
INSERT INTO SALGRADE(GRADE, LOSAL, HTSAL) VALUES(3, 1401, 2000);
INSERT INTO SALGRADE(GRADE, LOSAL, HTSAL) VALUES(4, 2001, 3000);
INSERT INTO SALGRADE(GRADE, LOSAL, HTSAL) VALUES(5, 3001, 9999);

SELECT * FROM BONUS;
```

### 单表查询 select查询

```mysql
--  查询emp表
select * from emp;

-- 显示部分列 
select empno, ename,job from emp;

-- 显示部分行
SELECT * from emp where sal>2000;

-- 显示部分行，部分列
select empno,ename,job,mgr from emp where sal>2000;

-- 起别名
select empno 员工编号,ename 姓名 ,sal 工资 from emp;
select empno as 员工编号,ename as 姓名 ,sal as 工资 from emp;
select empno as '员工编号',ename as '姓名' ,sal as '工资' from emp;

-- 在别名中含有特殊符合时,''或者""不可以省略

-- 算术运算符
SELECT empno,ename,sal,sal+1000 as '涨薪后',deptno from emp where sal > 2500;

-- 去重操作
select job from emp;
select DISTINCT job from emp;

-- 排序
select * from emp ORDER BY sal;  -- 默认按照升序排列
select * from emp ORDER BY sal asc;    -- asc 升序 可以不写
select * from emp ORDER BY sal desc;   -- desc 降序
select * from emp ORDER BY sal asc, deptno desc;
```

### where子句

```mysql
-- 查询emp表
select * from emp;

-- where子句后面接条件 关系运算符
select * from emp where deptno =10;
select * from emp where deptno >10;
select * from emp where deptno <10;
select * from emp where deptno <=10;
select * from emp where deptno >=10;
select * from emp where deptno <>10;
select * from emp where deptno !=10;
select * from emp where job='clerk';  -- 默认情况下不区大小写
select * from emp where BINARY job='clerk';  -- BINARY区分大小写

-- where子句后面接逻辑运算符and
select * from emp where sal > 1500 and sal < 3000 ORDER BY sal;  -- 左右不包含
select * from emp where sal BETWEEN 1500 and 3000; -- BETWEEN 包含1500和3000
select * from emp where sal > 1500 && sal < 3000;

-- where子句后面接逻辑运算符or
select * from emp where deptno = 20 or deptno =10;
select * from emp where deptno = 20 || deptno =10;
select * from emp where deptno in (10,20);

-- where子句 模糊查询
-- 查询名字中带A的
select * from emp where ename like '%A%';
select * from emp where ename like '_A%';  -- A在第二位
select * from emp where ename like '__A%'; -- A在第三位

-- where子句 关于null的判断
select * from emp where comm is null;
select * from emp where comm is not null;

-- 小括号的使用  and的优先级大于or
select * from emp where job='SALESMAN' or job='clerk' and sal>=1500;
select * from emp where (job='SALESMAN' or job='clerk') and sal>=1500;
select * from emp where job='SALESMAN' or (job='clerk' and sal>=1500);
```

### 函数

```mysql
select * from emp;
-- 函数举例
select empno,lower(ename),upper(ename),sal from emp;
select max(sal),min(sal),avg(sal),count(sal),sum(sal) from emp;

/*
函数的功能：封装了一些特定的功能，可以直接拿过来用
函数的作用：为了提高查询的能力
注意：函数没有改变数据自身的值，只是在真实的数据上进行加工处理，展示新的结果而已
函数的分类：
	lower(ename),upper(ename)  单行函数
		单行函数：
			对每一条记录进行计算，得到相应的结果，然后返回
			 		  常用的单行函数包括：字符串函数，日期函数，数据函数和时间函数，流程函数以及其他函数
	max(sal),min(sal),avg(sal),count(sal),sum(sal) 多行函数
		多行函数：对一组数据进行计算，针对这一组数据只返回一个结果，也分为分组函数
	除了多行函数，都是单行函数
*/
```

#### 单行函数

```mysql
/*
单行函数包括：
	① 字符串函数
	② 数值函数
	③ 日期与时间函数
	④ 流程函数
	⑤ JSON函数
	⑥ 其他函数
*/
-- ① 字符串函数  SUBSTRING用来截取字符串 2代表开始的位置，3代表结束的位置 索引从1开始
SELECT ename, LENGTH(ename), SUBSTRING(ENAME, 2, 3) from emp;


-- ② 数值函数  abs绝对值 ceil 向上取整 floor 向下取整  round四舍五入
select abs(-5),ceil(5.3),floor(5.9),round(3.14) from dual; -- dual是一个伪表
select abs(-5),ceil(5.3),floor(5.9),round(3.14); -- 没有where子句，from可省
select mod(10, 3);  -- mod取模函数

-- ③ 日期与时间函数
select curdate(), curtime(); -- curdate() 年月日 curtime()时分秒

-- now()当前时间 年月日时分秒   sysdate() 系统时间   年月日时分秒    sysdate()是函数执行完毕后的时间 
-- now() 虽然是年月日时分秒，但是插入数据时还得参照表结构 date类型是年月日 datetime类型是年月日时分秒
select now(),sysdate(),sleep(3), now(), sysdate() from dual; 

-- ④ 流程函数
-- if相关
-- if-else 双分支结构
select empno,ename,sal, if(sal > 2500, '高薪', '低薪') as '薪资等级' from emp;
-- ifnull(value,0) 如果传入的值是null，则取值为0
select empno,ename,comm,sal+ifnull(comm,0) as '总薪资' from emp; 
-- nullif(value1,value2) 如果value1等于value2,取值null,如果不相等，取值value1
select nullif(1,1),nullif(1,2) from dual;

-- case相关
-- case等值判断
select * from emp;
select empno,ename,job,
case job
	when 'CLERK' then '店员'
	when 'SALESMAN' then '销售'
	when 'MANAGER' then '经理'
	else '其他'
end '岗位',
sal from emp;

-- case区间判断
select empno,ename,sal,
case
	when sal <= 1000 then 'A'
	when sal <= 2000 then 'B'
	when sal <= 3000 then 'C'
	else 'D'
end '工资等级',
deptno from emp;


-- ⑥ 其他函数
select database(), user(),version() from dual;
```

#### 多行函数

```mysql
/*
单行函数包括：
	① 字符串函数
	② 数值函数
	③ 日期与时间函数
	④ 流程函数
	⑤ JSON函数
	⑥ 其他函数
*/
-- ① 字符串函数  SUBSTRING用来截取字符串 2代表开始的位置，3代表结束的位置 索引从1开始
SELECT ename, LENGTH(ename), SUBSTRING(ENAME, 2, 3) from emp;


-- ② 数值函数  abs绝对值 ceil 向上取整 floor 向下取整  round四舍五入
select abs(-5),ceil(5.3),floor(5.9),round(3.14) from dual; -- dual是一个伪表
select abs(-5),ceil(5.3),floor(5.9),round(3.14); -- 没有where子句，from可省
select mod(10, 3);  -- mod取模函数

-- ③ 日期与时间函数
select curdate(), curtime(); -- curdate() 年月日 curtime()时分秒

-- now()当前时间 年月日时分秒   sysdate() 系统时间   年月日时分秒    sysdate()是函数执行完毕后的时间 
-- now() 虽然是年月日时分秒，但是插入数据时还得参照表结构 date类型是年月日 datetime类型是年月日时分秒
select now(),sysdate(),sleep(3), now(), sysdate() from dual; 

-- ④ 流程函数
-- if相关
-- if-else 双分支结构
select empno,ename,sal, if(sal > 2500, '高薪', '低薪') as '薪资等级' from emp;
-- ifnull(value,0) 如果传入的值是null，则取值为0
select empno,ename,comm,sal+ifnull(comm,0) as '总薪资' from emp; 
-- nullif(value1,value2) 如果value1等于value2,取值null,如果不相等，取值value1
select nullif(1,1),nullif(1,2) from dual;

-- case相关
-- case等值判断
select * from emp;
select empno,ename,job,
case job
	when 'CLERK' then '店员'
	when 'SALESMAN' then '销售'
	when 'MANAGER' then '经理'
	else '其他'
end '岗位',
sal from emp;

-- case区间判断
select empno,ename,sal,
case
	when sal <= 1000 then 'A'
	when sal <= 2000 then 'B'
	when sal <= 3000 then 'C'
	else 'D'
end '工资等级',
deptno from emp;


-- ⑥ 其他函数
select database(), user(),version() from dual;

-- 多行函数  max(),min(),count()针对所有类型  avg(),sum() 只针对数值类型
select sum(sal), avg(sal), max(sal), min(sal), count(sal) from emp;
-- 统计表的记录数：方法一
select count(*) from emp;

-- 统计表的记录数：方法二
select 1 from dual;
select 1 from emp;
select count(1) from emp;
```

### 分组 groupy by

```mysql
select * from emp;
select deptno, avg(sal) from emp group by deptno;
select job,avg(sal) from emp group by job order by sal desc;
```

### having分组后筛选

```mysql
select * from emp;

select deptno,avg(sal) '平均工资' from emp group by deptno having avg(sal) > 2000;
select deptno,avg(sal) 平均工资 from emp group by deptno having 平均工资 > 2000 order by deptno desc;

-- 统计各个岗位的平均工资，除了MANAGER
-- 方法一，使用where子句
select job, avg(sal) from emp where job != 'MANAGER' group by job;
-- 方法二，使用having
select job, avg(sal) from emp group by job having job != 'MANAGER';

-- where子句在分组前进行过滤，having在分组后进行过滤
```

单表查询练习

```mysql
select * from emp;
-- 列出工资最小值小于2000的职位
select job,sal from emp group by job having sal < 2000;

-- 列出平均工资大于1200的元的部门和工作搭配组合
select deptno,job,avg(sal) from emp group by deptno,job having avg(sal) > 1200;

-- 统计人数小于4的部门的平均工资
select deptno,count(1), avg(sal) from  emp group by deptno having count(1) < 4;

-- 统计各部门的最高工资，排除最高工资小于3000的部门
select deptno,max(sal) from emp group by deptno having max(sal) < 3000;
```

### 多表查询

#### SQL99语法：交叉，自然，内连接查询

```mysql
-- 查询员工表
select * from emp;
select empno, ename,deptno from emp;

-- 查询部门表
select * from dept;

-- 多表查询
-- 交叉连接 cross join
select * 
from emp
cross join dept;   -- 结果有56条记录  笛卡尔乘积 没有实际意义

select * from emp cross join dept;

-- 自然连接 natural join  优点：自动匹配所有的同名列，同名列只展示一次。
select * from emp natural join dept;

-- 表中查询指定的字段
select empno,ename,sal,dname,loc from emp natural join dept;

-- 缺点效率低  解决使用数据表名.字段名
select emp.empno,emp.ename,emp.sal,dept.dname,dept.loc from emp natural join dept;

-- 缺点： 表名太长 解决：使用别名
select e.empno,e.ename,e.sal,d.dname,d.loc 
from emp  e
natural join 
dept d;

-- 内连接  using子句
-- 自然选择 natural join 缺点：会自动匹配数据表中的所有同名列 但有时候只想匹配部分列
-- 解决办法：使用using子句
select * from emp e 
inner join dept d   -- inner可以省略
using(deptno);      -- using匹配部分同名列

-- 内连接  on 子句
-- using缺点  关联的字段必须是同名的
-- 解决方式： on子句
select * from emp e 
inner join dept d
on(e.deptno=d.deptno);

 -- 多表连接查询的类型： 1.交叉连接 cross join  2.自然连接  natural join 3.内连接 using 子句 4.内连接 on子句 
-- on 子句用的多


/*
筛选条件： where（分组前）　　　having（分组后）
连接条件: using ,on, natural 
SQL99语法：筛选条件和连接条件分开
*/
```

#### SQL99语法：外连接

```mysql
-- 内连接只能显示出匹配的内容 inner join
-- 解决方式： 使用外连接 外连接分为左外连接（left outer join）和右外连接（right outer join）
-- 左外连接 只显示左边的表，显示出不匹配的内容
select * from emp e left outer join dept d on e.DEPTNO=d.DEPTNO;  -- outer可以省略

-- 右外连接  只显示右边的表  显示出不匹配的内容
select * from emp e right outer join dept d on e.DEPTNO=d.DEPTNO;

-- 显示所有的不匹配的内容  full outer   这种方式在MySQL种不支持  在orcal中支持
select * from emp e full outer join dept d on e.DEPTNO=d.DEPTNO;

-- 解决MySQL中无法显示所有匹配内容的问题 使用并集
select * from emp e left outer join dept d on e.DEPTNO=d.DEPTNO
union  -- 会自动进行去重  效率低
select * from emp e right outer join dept d on e.DEPTNO=d.DEPTNO;

select * from emp e left outer join dept d on e.DEPTNO=d.DEPTNO
union all  -- 不会进行去重 效率高
select * from emp e right outer join dept d on e.DEPTNO=d.DEPTNO;

-- MySQL对集合操作支持弱，只支持并集 不支持交集和差集 orcal都支持
```

#### 三表查询

```mysql
-- 查询员工的编号，姓名，薪水，部门编号,部门名称，薪水的等级
select * from emp;
select * from dept;
select * from salgrade;

select * from 
emp e 
inner join dept d 
on e.DEPTNO = d.DEPTNO
inner join salgrade s
on e.sal between s.LOSAL and s.HTSAL;

select * from 
emp e 
right outer join dept d 
on e.DEPTNO = d.DEPTNO
inner join salgrade s
on e.sal between s.LOSAL and s.HTSAL;
```

#### 自连接

```mysql
-- 查询员工的编号，姓名，上级编号，上级姓名
select * from emp;

-- 自连接
select e1.EMPNO 员工编号, e1.ENAME 员工姓名,e1.MGR 员工领导编号,e2.ENAME 员工上级姓名  from 
emp e1 
inner join emp e2
on e1.MGR = e2.EMPNO;

-- 左外连接
select e1.EMPNO 员工编号, e1.ENAME 员工姓名,e1.MGR 员工领导编号,e2.ENAME 员工上级姓名  from 
emp e1 
left outer join emp e2
on e1.MGR = e2.EMPNO;
```

### 子查询

子查询：一个sql语句有多个select语句

相关子查询的执行顺序：先执行外查询，在执行子查询

不相关子查询：子查询可以独立运行，称为不相关子查询

不相关子查询可以分为：单行不相关子查询和多行不相关子查询

#### 单行子查询

```mysql
-- 查询所有比'clark'工资高的人
select * from emp;
select * from emp where ename = 'clark'; 
select ename,sal from emp where sal > 2500;

select ename,sal from emp where sal > (select sal from emp where ename = 'clark');

-- 查询工资高于平均工资的员工姓名和工资
select ename, sal from emp where sal > (select avg(sal) from emp);

-- 查询和clark在同一部门并且工资低于他的员工名字和工资
select ename,sal from emp where DEPTNO = (select deptno from emp where ename = 'clark')
and sal < (select sal from emp where ename='clark');

-- 查询职务和scott相同，比scott入职时间早的员工信息
select * from emp where job = (select job from emp where ename ='scott') 
and 
HIREDATE < (select HIREDATE from emp where ENAME='scott');
```

#### 多行子查询

```mysql
select * from emp;
-- 查询部门20中职务同部门10中员工职务一样的员工信息
select job from emp where DEPTNO=20;
select job from emp where DEPTNO=10;
select * from emp where DEPTNO=20 and job = any(select job from emp where DEPTNO=10);
select * from emp where DEPTNO=20 and job in (select job from emp where DEPTNO=10);

-- 查询工资比所有SALESMAN高的员工名字，员工编号和工资
select ename,empno,sal from emp where sal > all(select sal from emp where job='SALESMAN');
select ename,empno,sal from emp where sal > (select max(sal) from emp where job='SALESMAN');

-- 查询工资低于任意一个clerk的工资的员工信息
select * from emp where sal < (select max(sal) from emp where job='clerk') and job!='clerk';
```

### 相关子查询

不相关的子查询:子查询可以独立运行，先运行子查询，在运行外查询

相关子查询：子查询不能独立运行，先执行外查询，在执行子查询

优点：简单，功能强大（一些使用不相关子查询不能实现或者实现繁琐的子查询，可以使用相关的子查询实现）

缺点：稍难理解

```mysql
-- 查询最高工资的员工  (不相关子查询)
select * from emp where sal = (select max(sal) from emp);
-- 查询部门最高工资的员工（相关子查询）
-- 方法一： 通过不相关子查询
select * from emp where deptno = 10 and sal = (select max(sal) from emp where deptno = 10) union
select * from emp where deptno = 20 and sal = (select max(sal) from emp where deptno = 20) union
select * from emp where deptno = 30 and sal = (select max(sal) from emp where deptno = 30);
-- 缺点：对于有多个部门未知
-- 方法二： 通过相关子查询
select * from emp e where sal = (select max(sal) from emp where deptno=e.DEPTNO) ORDER BY DEPTNO;

-- 查询工资高于其所在岗位的平均工资的那些员工(相关子查询)
select * from emp e where sal >= (select avg(sal) from emp where job=e.JOB) order by DEPTNO;
```

### 事务及其特征

事务是用来维护数据库完整性的，它能够保证一系列的MySQL操作要么全部执行，要么全不执行

ACID：原子性，一致性，隔离性，持久性

原子性：具有不可分割的特性，要么全部执行，要么全不执行

一致性：事务执行的结果必须从一个状态变到另一个一致性状态，一致性通过原子性来保证

隔离性：指各个事务的执行互不干扰

持久性：事务一旦提交，对数据所做的任何的改动，都要永久记录到存储器中

```mysql
-- 创建资金表
create table account(
	id int(3) primary key auto_increment,
	uname varchar(10) not null,
	balance double
);

select * from account;

-- 插入数据
insert into account VALUES (null, '王五', 2000), (null, '李四', 2000);

-- 更新数据
update account set balance = balance - 200 where id =1;
update account set balance = balance + 200 where id =2;

-- 开启一个事务
start transaction;
update account set balance = balance - 200 where id =1;
update account set balance = balance + 200 where id =2;

-- 回滚
rollback;

-- 提交
commit;

-- 在回滚和提交之前，数据库中的数据都是操作的缓存里的数据，而不是数据表里的数据
```

### 事务并发问题

事务并发问题：

​	① 脏读

​	② 不可重复读

​	③ 幻读

### 事务隔离级别

read uncommitted < read committed < repeatable read < serializable

```mysql
-- 查看当前数据库的隔离级别  mysql默认的是repeatable read
select @@transaction_isolation;

-- 设置事务的隔离级别 (设置当前会话的隔离级别)
set session transaction isolation level read uncommitted;
set session transaction isolation level read committed;
set session transaction isolation level repeatable read;
set session transaction isolation level serializable;
```

### 视图

```mysql
-- 创建或者替换一个视图
create or replace view myview01
as 
select empno,ename,job,deptno from emp
where deptno = 20
with check option;   -- 进行校验
 
select * from myview01;
 
-- 在视图中插入数据
insert into myview01(empno,ename,job,deptno) values (9999, 'lili', 'clerk', 20);
-- 30部门无法插入进去，视图规定了部门为20
insert into myview01(empno,ename,job,deptno) values (8888, 'li', 'clerk', 30);

select * from emp;
select * from dept;

-- 创建多表视图
create or replace view myview02
as 
select e.empno,e.ename, e.sal,d.dname
from emp e 
join dept d
on e.DEPTNO=d.deptno
where sal > 2000;
select * from myview02;

-- 创建统计视图
create or replace view myview03
as 
select e.deptno,e.ename,e.job,d.dname,min(sal), avg(sal),count(1)
from emp e 
join dept d 
using(deptno)
GROUP BY DEPTNO;

select * from myview03;

-- 创建基于视图的视图
create or replace view myview04
as
select * from myview03 where deptno=20;
select * from myview04;
```

### 存储过程

存储过程是数据库中保存的一系列SQL命令的集合

```mysql
-- 创建一个没有返回值的存储过程
-- 创建一个模糊查询的存储过程
create procedure mypro01(name varchar(10)) 
begin
	if name is null or name = "" then
		select * from emp;
	else
		select * from emp where ename like concat('%', name, '%');
	end if;
end;

-- 删除存储过程
drop procedure mypro01;

-- 调用存储过程
call mypro01('');
call mypro01('R');

-- 创建一个带有返回值的存储过程，实现模糊查询
-- in代表是参数 out代表是返回值
create procedure mypro02(in name varchar(10), out num int(3)) 
begin
	if name is null or name = "" then
		select * from emp;
	else
		select * from emp where ename like concat('%', name, '%');
	end if;
	-- 将结果返回
	select found_rows() into num;
end;

-- 调用存储过程
call mypro02('', @num);
select @num;
call mypro02('R', @aaa);
select @aaa;
```

### Python操作数据库

#### 类的封装

```python
from pymysql import *


class Mysqlhelp():
    connect_params = {
        'host': 'localhost',
        'user': 'root',
        'password': 'itcast',
        'db': 'mytestdb'
    }

    def __init__(self, connect_params):
        """
        初始化类属性
        :param connect_params:
        """
        self.__host = connect_params['host']
        self.__user = connect_params['user']
        self.__password = connect_params['password']
        self.__db = connect_params['db']

    def __connect(self):
        """
        创建数据库连接
        :return:
        """
        self.__connect = Connect(host=self.__host, user=self.__user, password=self.__password, database=self.__db)
        self.__cursor = self.__connect.cursor()

    def __colse(self):
        """
        关闭连接和游标
        :return:
        """
        self.__connect.close()
        self.__cursor.close()

    def get_one(self, sql, params):
        """
        获取单条数据
        :param sql:
        :param params:
        :return:
        """
        result = None
        try:
            self.__connect()
            self.__cursor.execute(sql, params)
            result = self.__cursor.fetchone()
            self.__connect.close()
        except Exception as e:
            raise e
        return result

    def get_all(self, sql, params):
        """
        获取所有数据
        :param sql:
        :param params:
        :return:
        """
        result = ()
        try:
            self.__connect()
            self.__cursor.execute(sql, params)
            result = self.__cursor.fetchall()
            self.__connect.close()
        except Exception as e:
            raise e
        return result

    def insert(self, sql, params):
        """
        插入数据
        :param sql:
        :param params:
        :return:
        """
        return self.__edit(sql, params)

    def insert_many(self, sql, params):
        result_list = []
        try:
            self.__connect()
            result_list = self.__cursor.executemany(sql, params)
            self.__connect.commit()
            self.__connect.close()
        except Exception as e:
            raise e
        return result_list

    def delete(self, sql, params):
        """
        删除数据
        :param sql:
        :param params:
        :return:
        """
        return self.__edit(sql, params)

    def update(self, sql, params):
        """
        更新数据
        :param sql:
        :param params:
        :return:
        """
        return self.__edit(sql, params)

    def __edit(self, sql, params):
        count = 0
        try:
            self.__connect()
            count = self.__cursor.execute(sql, params)
            self.__connect.commit()
            self.__connect.close()
        except Exception as e:
            raise e
        return count
```

#### 调用类

```python
from Python与MySQ交互.mysql_cusm import *

mysqlcusm = Mysqlhelp(Mysqlhelp.connect_params)
# 插入数据
# sql = 'insert into student_ values (%s,%s,%s,%s,%s,%s)'
# params = [(11, '北京', '986499', '男', '2021-10-12', 345), (12, '上海', '986499', '男', '2021-10-12', 345)]
# rowcont = mysqlcusm.insert_many(sql, params)
# print(f'成功插入{rowcont}条数据')

# 修改数据
# sql = 'update student_ set name=%s where id=%s'
# pararms = ('深圳', 11)
# rowcount = mysqlcusm.update(sql,pararms)
# print(f'成功修改{rowcount}条数据')

# 删除数据
# sql = 'delete from student_ where id=%s'
# params=(9)
# rowcount = mysqlcusm.delete(sql,params)
# print(f'成功删除{rowcount}条数据')

# 查询
sql = 'select name,age,sex from student_ where age>%s'
params=(19)
rowcount = mysqlcusm.get_all(sql,params)
for row in rowcount:
    print(row)
```

### MySQL调优

![image-20210529160309746](C:\Users\20622\AppData\Roaming\Typora\typora-user-images\image-20210529160309746.png)

mysql优化器分为两种：

​	① RBO:基于规则的优化器

​	② CBO：基于成本的优化器(用的多)

mysql查看sql语句的时间    

https://dev.mysql.com/doc/refman/8.0/en/show-profile.html 

```
设置一个状态
set profiling=1;
执行一条sql语句
 select * from student;
 查看 
 show profiles;
 查看具体
 show profile;
 
 查看所有语句的执行时间
 show profiles;
 查看某条语句的执行时间  n表示第几个sql语句
 show profile for query n;
 查看cpu的使用
 show profile cpu;
 查看所有
 show profile all;
```

mysql输入命令   show tables;后，会默认出现一个表performance_schema，这个表是mysql的性能优化

官网：https://dev.mysql.com/doc/refman/8.0/en/performance-schema.html

默认是开启的

 SHOW VARIABLES LIKE 'performance_schema';  进行状态的查看

![image-20210529135133983](C:\Users\20622\AppData\Roaming\Typora\typora-user-images\image-20210529135133983.png)

 show processlist; 查看有多少个连接



# MYSQL performance schema详解

### 0、performance_schema的介绍

​		**MySQL的performance schema 用于监控MySQL server在一个较低级别的运行过程中的资源消耗、资源等待等情况**。

​		特点如下：

​		1、提供了一种在数据库运行时实时检查server的内部执行情况的方法。performance_schema 数据库中的表使用performance_schema存储引擎。该数据库主要关注数据库运行过程中的性能相关的数据，与information_schema不同，information_schema主要关注server运行过程中的元数据信息

​		2、performance_schema通过监视server的事件来实现监视server内部运行情况， “事件”就是server内部活动中所做的任何事情以及对应的时间消耗，利用这些信息来判断server中的相关资源消耗在了哪里？一般来说，事件可以是函数调用、操作系统的等待、SQL语句执行的阶段（如sql语句执行过程中的parsing 或 sorting阶段）或者整个SQL语句与SQL语句集合。事件的采集可以方便的提供server中的相关存储引擎对磁盘文件、表I/O、表锁等资源的同步调用信息。
​		3、performance_schema中的事件与写入二进制日志中的事件（描述数据修改的events）、事件计划调度程序（这是一种存储程序）的事件不同。performance_schema中的事件记录的是server执行某些活动对某些资源的消耗、耗时、这些活动执行的次数等情况。
​		4、performance_schema中的事件只记录在本地server的performance_schema中，其下的这些表中数据发生变化时不会被写入binlog中，也不会通过复制机制被复制到其他server中。
​		5、 当前活跃事件、历史事件和事件摘要相关的表中记录的信息。能提供某个事件的执行次数、使用时长。进而可用于分析某个特定线程、特定对象（如mutex或file）相关联的活动。
​		6、PERFORMANCE_SCHEMA存储引擎使用server源代码中的“检测点”来实现事件数据的收集。对于performance_schema实现机制本身的代码没有相关的单独线程来检测，这与其他功能（如复制或事件计划程序）不同
​		7、收集的事件数据存储在performance_schema数据库的表中。这些表可以使用SELECT语句查询，也可以使用SQL语句更新performance_schema数据库中的表记录（如动态修改performance_schema的setup_*开头的几个配置表，但要注意：配置表的更改会立即生效，这会影响数据收集）
​		8、performance_schema的表中的数据不会持久化存储在磁盘中，而是保存在内存中，一旦服务器重启，这些数据会丢失（包括配置表在内的整个performance_schema下的所有数据）
​		9、MySQL支持的所有平台中事件监控功能都可用，但不同平台中用于统计事件时间开销的计时器类型可能会有所差异。

### 1、performance schema入门

​		在mysql的5.7版本中，性能模式是默认开启的，如果想要显式的关闭的话需要修改配置文件，不能直接进行修改，会报错Variable 'performance_schema' is a read only variable。

```sql
--查看performance_schema的属性
mysql> SHOW VARIABLES LIKE 'performance_schema';
+--------------------+-------+
| Variable_name      | Value |
+--------------------+-------+
| performance_schema | ON    |
+--------------------+-------+
1 row in set (0.01 sec)

--在配置文件中修改performance_schema的属性值，on表示开启，off表示关闭
[mysqld]
performance_schema=ON

--切换数据库
use performance_schema;

--查看当前数据库下的所有表,会看到有很多表存储着相关的信息
show tables;

--可以通过show create table tablename来查看创建表的时候的表结构
mysql> show create table setup_consumers;
+-----------------+---------------------------------
| Table           | Create Table                    
+-----------------+---------------------------------
| setup_consumers | CREATE TABLE `setup_consumers` (
  `NAME` varchar(64) NOT NULL,                      
  `ENABLED` enum('YES','NO') NOT NULL               
) ENGINE=PERFORMANCE_SCHEMA DEFAULT CHARSET=utf8 |  
+-----------------+---------------------------------
1 row in set (0.00 sec)                             
```

​		想要搞明白后续的内容，同学们需要理解两个基本概念：

​		instruments: 生产者，用于采集mysql中各种各样的操作产生的事件信息，对应配置表中的配置项我们可以称为监控采集配置项。

​		consumers:消费者，对应的消费者表用于存储来自instruments采集的数据，对应配置表中的配置项我们可以称为消费存储配置项。

### 2、performance_schema表的分类

​		performance_schema库下的表可以按照监视不同的纬度就行分组。

```sql
--语句事件记录表，这些表记录了语句事件信息，当前语句事件表events_statements_current、历史语句事件表events_statements_history和长语句历史事件表events_statements_history_long、以及聚合后的摘要表summary，其中，summary表还可以根据帐号(account)，主机(host)，程序(program)，线程(thread)，用户(user)和全局(global)再进行细分)
show tables like '%statement%';

--等待事件记录表，与语句事件类型的相关记录表类似：
show tables like '%wait%';

--阶段事件记录表，记录语句执行的阶段事件的表
show tables like '%stage%';

--事务事件记录表，记录事务相关的事件的表
show tables like '%transaction%';

--监控文件系统层调用的表
show tables like '%file%';

--监视内存使用的表
show tables like '%memory%';

--动态对performance_schema进行配置的配置表
show tables like '%setup%';
```

### 3、performance_schema的简单配置与使用

​		数据库刚刚初始化并启动时，并非所有instruments(事件采集项，在采集项的配置表中每一项都有一个开关字段，或为YES，或为NO)和consumers(与采集项类似，也有一个对应的事件类型保存表配置项，为YES就表示对应的表保存性能数据，为NO就表示对应的表不保存性能数据)都启用了，所以默认不会收集所有的事件，可能你需要检测的事件并没有打开，需要进行设置，可以使用如下两个语句打开对应的instruments和consumers（行计数可能会因MySQL版本而异)。

```sql
--打开等待事件的采集器配置项开关，需要修改setup_instruments配置表中对应的采集器配置项
UPDATE setup_instruments SET ENABLED = 'YES', TIMED = 'YES'where name like 'wait%';

--打开等待事件的保存表配置开关，修改setup_consumers配置表中对应的配置项
UPDATE setup_consumers SET ENABLED = 'YES'where name like '%wait%';

--当配置完成之后可以查看当前server正在做什么，可以通过查询events_waits_current表来得知，该表中每个线程只包含一行数据，用于显示每个线程的最新监视事件
select * from events_waits_current\G
*************************** 1. row ***************************
            THREAD_ID: 11
             EVENT_ID: 570
         END_EVENT_ID: 570
           EVENT_NAME: wait/synch/mutex/innodb/buf_dblwr_mutex
               SOURCE: 
          TIMER_START: 4508505105239280
            TIMER_END: 4508505105270160
           TIMER_WAIT: 30880
                SPINS: NULL
        OBJECT_SCHEMA: NULL
          OBJECT_NAME: NULL
           INDEX_NAME: NULL
          OBJECT_TYPE: NULL
OBJECT_INSTANCE_BEGIN: 67918392
     NESTING_EVENT_ID: NULL
   NESTING_EVENT_TYPE: NULL
            OPERATION: lock
      NUMBER_OF_BYTES: NULL
                FLAGS: NULL
/*该信息表示线程id为11的线程正在等待buf_dblwr_mutex锁，等待事件为30880
属性说明：
	id:事件来自哪个线程，事件编号是多少
	event_name:表示检测到的具体的内容
	source:表示这个检测代码在哪个源文件中以及行号
	timer_start:表示该事件的开始时间
	timer_end:表示该事件的结束时间
	timer_wait:表示该事件总的花费时间
注意：_current表中每个线程只保留一条记录，一旦线程完成工作，该表中不会再记录该线程的事件信息
*/

/*
_history表中记录每个线程应该执行完成的事件信息，但每个线程的事件信息只会记录10条，再多就会被覆盖，*_history_long表中记录所有线程的事件信息，但总记录数量是10000，超过就会被覆盖掉
*/
select thread_id,event_id,event_name,timer_wait from events_waits_history order by thread_id limit 21;

/*
summary表提供所有事件的汇总信息，该组中的表以不同的方式汇总事件数据（如：按用户，按主机，按线程等等）。例如：要查看哪些instruments占用最多的时间，可以通过对events_waits_summary_global_by_event_name表的COUNT_STAR或SUM_TIMER_WAIT列进行查询（这两列是对事件的记录数执行COUNT（*）、事件记录的TIMER_WAIT列执行SUM（TIMER_WAIT）统计而来）
*/
SELECT EVENT_NAME,COUNT_STAR FROM events_waits_summary_global_by_event_name  ORDER BY COUNT_STAR DESC LIMIT 10;

/*
instance表记录了哪些类型的对象会被检测。这些对象在被server使用时，在该表中将会产生一条事件记录，例如，file_instances表列出了文件I/O操作及其关联文件名
*/
select * from file_instances limit 20; 
```

### 4、常用配置项的参数说明

1、启动选项

```sql
performance_schema_consumer_events_statements_current=TRUE
是否在mysql server启动时就开启events_statements_current表的记录功能(该表记录当前的语句事件信息)，启动之后也可以在setup_consumers表中使用UPDATE语句进行动态更新setup_consumers配置表中的events_statements_current配置项，默认值为TRUE

performance_schema_consumer_events_statements_history=TRUE
与performance_schema_consumer_events_statements_current选项类似，但该选项是用于配置是否记录语句事件短历史信息，默认为TRUE

performance_schema_consumer_events_stages_history_long=FALSE
与performance_schema_consumer_events_statements_current选项类似，但该选项是用于配置是否记录语句事件长历史信息，默认为FALSE

除了statement(语句)事件之外，还支持：wait(等待)事件、state(阶段)事件、transaction(事务)事件，他们与statement事件一样都有三个启动项分别进行配置，但这些等待事件默认未启用，如果需要在MySQL Server启动时一同启动，则通常需要写进my.cnf配置文件中
performance_schema_consumer_global_instrumentation=TRUE
是否在MySQL Server启动时就开启全局表（如：mutex_instances、rwlock_instances、cond_instances、file_instances、users、hostsaccounts、socket_summary_by_event_name、file_summary_by_instance等大部分的全局对象计数统计和事件汇总统计信息表 ）的记录功能，启动之后也可以在setup_consumers表中使用UPDATE语句进行动态更新全局配置项
默认值为TRUE

performance_schema_consumer_statements_digest=TRUE
是否在MySQL Server启动时就开启events_statements_summary_by_digest 表的记录功能，启动之后也可以在setup_consumers表中使用UPDATE语句进行动态更新digest配置项
默认值为TRUE

performance_schema_consumer_thread_instrumentation=TRUE
是否在MySQL Server启动时就开启

events_xxx_summary_by_yyy_by_event_name表的记录功能，启动之后也可以在setup_consumers表中使用UPDATE语句进行动态更新线程配置项
默认值为TRUE

performance_schema_instrument[=name]
是否在MySQL Server启动时就启用某些采集器，由于instruments配置项多达数千个，所以该配置项支持key-value模式，还支持%号进行通配等，如下:

# [=name]可以指定为具体的Instruments名称（但是这样如果有多个需要指定的时候，就需要使用该选项多次），也可以使用通配符，可以指定instruments相同的前缀+通配符，也可以使用%代表所有的instruments

## 指定开启单个instruments

--performance-schema-instrument= 'instrument_name=value'

## 使用通配符指定开启多个instruments

--performance-schema-instrument= 'wait/synch/cond/%=COUNTED'

## 开关所有的instruments

--performance-schema-instrument= '%=ON'

--performance-schema-instrument= '%=OFF'

注意，这些启动选项要生效的前提是，需要设置performance_schema=ON。另外，这些启动选项虽然无法使用show variables语句查看，但我们可以通过setup_instruments和setup_consumers表查询这些选项指定的值。
```

2、系统变量

```sql
show variables like '%performance_schema%';
--重要的属性解释
performance_schema=ON
/*
控制performance_schema功能的开关，要使用MySQL的performance_schema，需要在mysqld启动时启用，以启用事件收集功能
该参数在5.7.x之前支持performance_schema的版本中默认关闭，5.7.x版本开始默认开启
注意：如果mysqld在初始化performance_schema时发现无法分配任何相关的内部缓冲区，则performance_schema将自动禁用，并将performance_schema设置为OFF
*/

performance_schema_digests_size=10000
/*
控制events_statements_summary_by_digest表中的最大行数。如果产生的语句摘要信息超过此最大值，便无法继续存入该表，此时performance_schema会增加状态变量
*/
performance_schema_events_statements_history_long_size=10000
/*
控制events_statements_history_long表中的最大行数，该参数控制所有会话在events_statements_history_long表中能够存放的总事件记录数，超过这个限制之后，最早的记录将被覆盖
全局变量，只读变量，整型值，5.6.3版本引入 * 5.6.x版本中，5.6.5及其之前的版本默认为10000，5.6.6及其之后的版本默认值为-1，通常情况下，自动计算的值都是10000 * 5.7.x版本中，默认值为-1，通常情况下，自动计算的值都是10000
*/
performance_schema_events_statements_history_size=10
/*
控制events_statements_history表中单个线程（会话）的最大行数，该参数控制单个会话在events_statements_history表中能够存放的事件记录数，超过这个限制之后，单个会话最早的记录将被覆盖
全局变量，只读变量，整型值，5.6.3版本引入 * 5.6.x版本中，5.6.5及其之前的版本默认为10，5.6.6及其之后的版本默认值为-1，通常情况下，自动计算的值都是10 * 5.7.x版本中，默认值为-1，通常情况下，自动计算的值都是10
除了statement(语句)事件之外，wait(等待)事件、state(阶段)事件、transaction(事务)事件，他们与statement事件一样都有三个参数分别进行存储限制配置，有兴趣的同学自行研究，这里不再赘述
*/
performance_schema_max_digest_length=1024
/*
用于控制标准化形式的SQL语句文本在存入performance_schema时的限制长度，该变量与max_digest_length变量相关(max_digest_length变量含义请自行查阅相关资料)
全局变量，只读变量，默认值1024字节，整型值，取值范围0~1048576
*/
performance_schema_max_sql_text_length=1024
/*
控制存入events_statements_current，events_statements_history和events_statements_history_long语句事件表中的SQL_TEXT列的最大SQL长度字节数。 超出系统变量performance_schema_max_sql_text_length的部分将被丢弃，不会记录，一般情况下不需要调整该参数，除非被截断的部分与其他SQL比起来有很大差异
全局变量，只读变量，整型值，默认值为1024字节，取值范围为0~1048576，5.7.6版本引入
降低系统变量performance_schema_max_sql_text_length值可以减少内存使用，但如果汇总的SQL中，被截断部分有较大差异，会导致没有办法再对这些有较大差异的SQL进行区分。 增加该系统变量值会增加内存使用，但对于汇总SQL来讲可以更精准地区分不同的部分。
*/
```

### 5、重要配置表的相关说明

​		配置表之间存在相互关联关系，按照配置影响的先后顺序，可添加为

![image-20191203125003597](C:\Users\63198\AppData\Roaming\Typora\typora-user-images\image-20191203125003597.png)

```sql
/*
performance_timers表中记录了server中有哪些可用的事件计时器
字段解释：
	timer_name:表示可用计时器名称，CYCLE是基于CPU周期计数器的定时器
	timer_frequency:表示每秒钟对应的计时器单位的数量,CYCLE计时器的换算值与CPU的频率相关、
	timer_resolution:计时器精度值，表示在每个计时器被调用时额外增加的值
	timer_overhead:表示在使用定时器获取事件时开销的最小周期值
*/
select * from performance_timers;

/*
setup_timers表中记录当前使用的事件计时器信息
字段解释：
	name:计时器类型，对应某个事件类别
	timer_name:计时器类型名称
*/
select * from setup_timers;

/*
setup_consumers表中列出了consumers可配置列表项
字段解释：
	NAME：consumers配置名称
	ENABLED：consumers是否启用，有效值为YES或NO，此列可以使用UPDATE语句修改。
*/
select * from setup_consumers;

/*
setup_instruments 表列出了instruments 列表配置项，即代表了哪些事件支持被收集：
字段解释：
	NAME：instruments名称，instruments名称可能具有多个部分并形成层次结构
	ENABLED：instrumetns是否启用，有效值为YES或NO，此列可以使用UPDATE语句修改。如果设置为NO，则这个instruments不会被执行，不会产生任何的事件信息
	TIMED：instruments是否收集时间信息，有效值为YES或NO，此列可以使用UPDATE语句修改，如果设置为NO，则这个instruments不会收集时间信息
*/
SELECT * FROM setup_instruments;

/*
setup_actors表的初始内容是匹配任何用户和主机，因此对于所有前台线程，默认情况下启用监视和历史事件收集功能
字段解释：
	HOST：与grant语句类似的主机名，一个具体的字符串名字，或使用“％”表示“任何主机”
	USER：一个具体的字符串名称，或使用“％”表示“任何用户”
	ROLE：当前未使用，MySQL 8.0中才启用角色功能
	ENABLED：是否启用与HOST，USER，ROLE匹配的前台线程的监控功能，有效值为：YES或NO
	HISTORY：是否启用与HOST， USER，ROLE匹配的前台线程的历史事件记录功能，有效值为：YES或NO
*/
SELECT * FROM setup_actors;

/*
setup_objects表控制performance_schema是否监视特定对象。默认情况下，此表的最大行数为100行。
字段解释：
	OBJECT_TYPE：instruments类型，有效值为：“EVENT”（事件调度器事件）、“FUNCTION”（存储函数）、“PROCEDURE”（存储过程）、“TABLE”（基表）、“TRIGGER”（触发器），TABLE对象类型的配置会影响表I/O事件（wait/io/table/sql/handler instrument）和表锁事件（wait/lock/table/sql/handler instrument）的收集
	OBJECT_SCHEMA：某个监视类型对象涵盖的数据库名称，一个字符串名称，或“％”(表示“任何数据库”)
	OBJECT_NAME：某个监视类型对象涵盖的表名，一个字符串名称，或“％”(表示“任何数据库内的对象”)
	ENABLED：是否开启对某个类型对象的监视功能，有效值为：YES或NO。此列可以修改
	TIMED：是否开启对某个类型对象的时间收集功能，有效值为：YES或NO，此列可以修改
*/
SELECT * FROM setup_objects;

/*
threads表对于每个server线程生成一行包含线程相关的信息，
字段解释：
	THREAD_ID：线程的唯一标识符（ID）
	NAME：与server中的线程检测代码相关联的名称(注意，这里不是instruments名称)
	TYPE：线程类型，有效值为：FOREGROUND、BACKGROUND。分别表示前台线程和后台线程
	PROCESSLIST_ID：对应INFORMATION_SCHEMA.PROCESSLIST表中的ID列。
	PROCESSLIST_USER：与前台线程相关联的用户名，对于后台线程为NULL。
	PROCESSLIST_HOST：与前台线程关联的客户端的主机名，对于后台线程为NULL。
	PROCESSLIST_DB：线程的默认数据库，如果没有，则为NULL。
	PROCESSLIST_COMMAND：对于前台线程，该值代表着当前客户端正在执行的command类型，如果是sleep则表示当前会话处于空闲状态
	PROCESSLIST_TIME：当前线程已处于当前线程状态的持续时间（秒）
	PROCESSLIST_STATE：表示线程正在做什么事情。
	PROCESSLIST_INFO：线程正在执行的语句，如果没有执行任何语句，则为NULL。
	PARENT_THREAD_ID：如果这个线程是一个子线程（由另一个线程生成），那么该字段显示其父线程ID
	ROLE：暂未使用
	INSTRUMENTED：线程执行的事件是否被检测。有效值：YES、NO 
	HISTORY：是否记录线程的历史事件。有效值：YES、NO * 
	THREAD_OS_ID：由操作系统层定义的线程或任务标识符（ID）：
*/
select * from threads
```

注意：在performance_schema库中还包含了很多其他的库和表，能对数据库的性能做完整的监控，大家需要参考官网详细了解。

### 6、performance_schema实践操作

​		基本了解了表的相关信息之后，可以通过这些表进行实际的查询操作来进行实际的分析。

```sql
--1、哪类的SQL执行最多？
SELECT DIGEST_TEXT,COUNT_STAR,FIRST_SEEN,LAST_SEEN FROM events_statements_summary_by_digest ORDER BY COUNT_STAR DESC
--2、哪类SQL的平均响应时间最多？
SELECT DIGEST_TEXT,AVG_TIMER_WAIT FROM events_statements_summary_by_digest ORDER BY COUNT_STAR DESC
--3、哪类SQL排序记录数最多？
SELECT DIGEST_TEXT,SUM_SORT_ROWS FROM events_statements_summary_by_digest ORDER BY COUNT_STAR DESC
--4、哪类SQL扫描记录数最多？
SELECT DIGEST_TEXT,SUM_ROWS_EXAMINED FROM events_statements_summary_by_digest ORDER BY COUNT_STAR DESC
--5、哪类SQL使用临时表最多？
SELECT DIGEST_TEXT,SUM_CREATED_TMP_TABLES,SUM_CREATED_TMP_DISK_TABLES FROM events_statements_summary_by_digest ORDER BY COUNT_STAR DESC
--6、哪类SQL返回结果集最多？
SELECT DIGEST_TEXT,SUM_ROWS_SENT FROM events_statements_summary_by_digest ORDER BY COUNT_STAR DESC
--7、哪个表物理IO最多？
SELECT file_name,event_name,SUM_NUMBER_OF_BYTES_READ,SUM_NUMBER_OF_BYTES_WRITE FROM file_summary_by_instance ORDER BY SUM_NUMBER_OF_BYTES_READ + SUM_NUMBER_OF_BYTES_WRITE DESC
--8、哪个表逻辑IO最多？
SELECT object_name,COUNT_READ,COUNT_WRITE,COUNT_FETCH,SUM_TIMER_WAIT FROM table_io_waits_summary_by_table ORDER BY sum_timer_wait DESC
--9、哪个索引访问最多？
SELECT OBJECT_NAME,INDEX_NAME,COUNT_FETCH,COUNT_INSERT,COUNT_UPDATE,COUNT_DELETE FROM table_io_waits_summary_by_index_usage ORDER BY SUM_TIMER_WAIT DESC
--10、哪个索引从来没有用过？
SELECT OBJECT_SCHEMA,OBJECT_NAME,INDEX_NAME FROM table_io_waits_summary_by_index_usage WHERE INDEX_NAME IS NOT NULL AND COUNT_STAR = 0 AND OBJECT_SCHEMA <> 'mysql' ORDER BY OBJECT_SCHEMA,OBJECT_NAME;
--11、哪个等待事件消耗时间最多？
SELECT EVENT_NAME,COUNT_STAR,SUM_TIMER_WAIT,AVG_TIMER_WAIT FROM events_waits_summary_global_by_event_name WHERE event_name != 'idle' ORDER BY SUM_TIMER_WAIT DESC
--12-1、剖析某条SQL的执行情况，包括statement信息，stege信息，wait信息
SELECT EVENT_ID,sql_text FROM events_statements_history WHERE sql_text LIKE '%count(*)%';
--12-2、查看每个阶段的时间消耗
SELECT event_id,EVENT_NAME,SOURCE,TIMER_END - TIMER_START FROM events_stages_history_long WHERE NESTING_EVENT_ID = 1553;
--12-3、查看每个阶段的锁等待情况
SELECT event_id,event_name,source,timer_wait,object_name,index_name,operation,nesting_event_id FROM events_waits_history_longWHERE nesting_event_id = 1553;
```



### MySQL对IP地址进行转换

对IP地址进行转换 使用 INET_ATON函数  节省存储空间

```SQL
mysql> select INET_ATON('192.168.85.111');
+-----------------------------+
| INET_ATON('192.168.85.111') |
+-----------------------------+
|                  3232257391 |
+-----------------------------+
1 row in set (0.00 sec)
```

将IP地址反转回来，使用INET_NTOA函数

```sql
mysql> select INET_NTOA('3232257391');
+-------------------------+
| INET_NTOA('3232257391') |
+-------------------------+
| 192.168.85.111          |
+-------------------------+
1 row in set (0.00 sec)
```

### MySQL枚举类

创建枚举类

```sqlite
mysql> create table enum_test(e enum('fish', 'apple', 'dog') not null);
```

插入数据

```sql
mysql> insert into enum_test(e) values('fish'), ('dog'), ('apple');
Query OK, 3 rows affected (0.01 sec)
Records: 3  Duplicates: 0  Warnings: 0
```

查询数据  以整形进行存储

```sql
mysql> select * from enum_test;
+-------+
| e     |
+-------+
| fish  |
| dog   |
| apple |
+-------+
3 rows in set (0.01 sec)

mysql> select e+0 from enum_test;
+-----+
| e+0 |
+-----+
|   1 |
|   3 |
|   2 |
+-----+
3 rows in set (0.00 sec)

mysql> select * from enum_test where e = 1;
+------+
| e    |
+------+
| fish |
+------+
1 row in set (0.11 sec)

mysql> select * from enum_test where e = 2;
+-------+
| e     |
+-------+
| apple |
+-------+
1 row in set (0.00 sec)

mysql> select * from enum_test where e = 3;
+-----+
| e   |
+-----+
| dog |
+-----+
1 row in set (0.00 sec)

mysql> select * from enum_test where e = 'fish';
+------+
| e    |
+------+
| fish |
+------+
1 row in set (0.00 sec)
```

### MySQL执行计划

```sql
mysql> explain select * from t_student;
+----+-------------+-----------+------+---------------+------+---------+------+------+-------+
| id | select_type | table     | type | possible_keys | key  | key_len | ref  | rows | Extra |
+----+-------------+-----------+------+---------------+------+---------+------+------+-------+
|  1 | SIMPLE      | t_student | ALL  | NULL          | NULL | NULL    | NULL |    4 |       |
+----+-------------+-----------+------+---------------+------+---------+------+------+-------+
1 row in set (0.05 sec)
```

#### 解决哈希冲突

存储引擎遍历链表中的所有行指针，逐行进行比较，直到找到所有符合条件的行

# 覆盖索引

1、当发起一个被索引覆盖的查询时，在explain的extra列可以看到using index的信息，此时就使用了覆盖索引

```sql
mysql> explain select store_id,film_id from inventory\G
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: inventory
   partitions: NULL
         type: index
possible_keys: NULL
          key: idx_store_id_film_id
      key_len: 3
          ref: NULL
         rows: 4581
     filtered: 100.00
        Extra: Using index
1 row in set, 1 warning (0.01 sec)
```

2、在大多数存储引擎中，覆盖索引只能覆盖那些只访问索引中部分列的查询。不过，可以进一步的进行优化，可以使用innodb的二级索引来覆盖查询。

例如：actor使用innodb存储引擎，并在last_name字段又二级索引，虽然该索引的列不包括主键actor_id，但也能够用于对actor_id做覆盖查询

```sql
mysql> explain select actor_id,last_name from actor where last_name='HOPPER'\G
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: actor
   partitions: NULL
         type: ref
possible_keys: idx_actor_last_name
          key: idx_actor_last_name
      key_len: 137
          ref: const
         rows: 2
     filtered: 100.00
        Extra: Using index
1 row in set, 1 warning (0.00 sec)
```

